# 企业应用架构模式阅读笔记

## 引言
- 企业应用和电信软件面临的不同挑战
    - 前者是复杂业务导致的复杂数据处理
    - 后者是高可靠性导致的多线程开发
    
- 企业应用开发时的常见约束条件
    - 持久化数据使用周期长
    - 设计大量数据
    - 多人同时访问数据
    - 有大量操作数据的用户界面屏幕
    - 需要与散布在企业周围的其他应用集成
    - 集成中 数据 / 概念的不一致性
    
- 企业应用的种类
    - B2C
        - 大量用户    
        - 简单业务逻辑
        - 高可伸缩性
    
    - 租约合同自动处理系统
        - 少量用户
        - 业务复杂        
        - 复杂界面
        - 超长事务
    
    - 开支跟踪系统
        - 用户少
        - 业务简单
        - 需要快速开发
        - 需要高可扩展性（易于为第三方系统集成）
    
- 性能
    - 眼见为实
    - 考量单位
        - 响应时间
        - 响应性（有没有假死）
        - 等待时间（网络延时等非编程可控等待时间）
        - 吞吐率（请求量/时间）
        - 负载
        - 负载敏感度（用户上升时，系统的负载上升速率）
        - 效率（性能/资源）
        - 可伸缩性（增加资源，硬件，对系统的影响）

- 模式
    - 使用时机
    - 意图和概要
    - 运行机制
    - 使用时机
    - 进一步阅读
    - 局限性
    
## 分层
    - 表现层（为外部提供服务的接口）
    - 领域层
    - 数据层（调用外部服务的接口）
    - 下层不依赖于上层

## 组织领域逻辑
- 主要模式
    - 事务脚本（面向过程的开发）
        - 优点：简单，边界明显
        - 缺点：过程内部可能包含了太多逻辑而导致程序复杂度变高
    - 领域模型（面向对象的开发）
        - 优点：容易在原有流程上扩展新的方法（因为所有处理后的结果都保存在了对象（的状态）内部）
        - 缺点：不容易确定对象的状态，因为有太多方法改变了状态
    - 表模块
        - 中间状态
- 选择
    - 复杂度（领域模型对代码复杂度的敏感度最低，但初始工作量最高）
    
## 映射到关系数据库
- 非关系型数据库
    - 缺点：没有通用语言
    - 优点：随取随用

- 关系型数据库
    - 优势：关系型数据库工具多
    - 缺点：需要为ORM映射付出代价
    - 常见映射方式：表 / 行
    
- ORM映射过程中的存
    - 如何保证在内存中的数据能正确的被更新到数据库中（而没有脏读，重复写入？）
    - 工作单元（数据库映射控制器）
    
- ORM映射过程中的取
    - 连接数据库的代价不小，如何以合适的阈值取出数据？
    
- 结构映射模式
    - 表关系（1-1,1-*,*-1,*-*）的映射
    - （实体）继承

- 建立映射

- 数据库连接

## Web表现层
- 服务器脚本
    - 适合解释请求信息

- 服务器页面
    - 适合格式化页面信息
    
- 视图-模型-控制器模式
    - 视图
        - 模板视图：可嵌套编程代码的视图（php，asp），常见于服务端代码
        - 转换视图：如果数据是XML，那使用XMLT 可以帮你快速转换出想要的结果
        - 两步视图：带母板页的视图
    
- 输入控制器模式
    - 在一个模块中，响应http，处理请求 
    - 在两个模块中，响应http，处理请求 

## 并发
- 本质上需要解决的问题
    - （写）更新丢失
    - （读）不一致读
    
- 执行语境（Execution Context）
    - 当前代码执行的环境的边界是什么？时间 / 空间 / 业务

- 隔离与不变性
- 乐观并发控制和悲观并发控制
    - 避免不一致读
    - 死锁

- 事务
    - ACID
    - 事务资源
    - 减少事务提高隔离性
    - 业务事务和系统事务（一个系统中的事务和多个系统中的事务）
    - 离线并发控制的模式
    - 应用服务器并发
    
## 会话状态
- 无状态的价值（服务器可以处理更多请求而不必为每个请求/会话消耗内存）
- 会话状态（在持久化之前（被业务事务处理之前）需要非持久化（驻留内存）的那部分内容）
- 存储会话状态的方法
    - 客户会话状态
    - 服务器会话状态
    - 数据库会话状态

    - 其他需要考虑的（会话迁移，取消会话，系统崩溃）
    
## 分布策略
- 需要考虑的问题：性能，构建难度，部署难度

- 尽量不使用分布对象（将一个表单的内容放在不同服务器上）的原因
    - 进程间通信（速度比进程内通信慢几个数量级）
    - 网络间传输（速度比进程间通信慢几个数量级）

- 分布式设计的常用方案（集群系统，在不同节点上部署同一应用程序的多个拷贝）

- 远程接口和本地接口设计上的不同
    - 本地接口细粒度（因为通信速度快）
    - 远程接口粗粒度（因为通信速度慢，所以通过粗粒度接口减少调用）
    
- 必须使用分布对象的情况
    - 客户端 《》服务器
    - 服务器《》数据库
    - 节约使用分布式对象
    
- 如何跨越分布边界
    - 利用粗粒度的对象
    - 将对象转为数据传输对象
    - xml / json

- 分布接口 / 协议
    - RPC
    - SOAP
    - HTTP-API

## 通盘考虑
- 人不可能一次考虑到所有问题，持续集成，测试驱动的开发，重构才是能够帮你应对变革的方法
- 需要考虑的一些问题
    - 数据源层
    - 变现层
    - 平台选择
    - 常见分层方式
    
----
# 模式

## 领域逻辑模式
- 领域模式
    - 事务模式（一段代码，展示需要考虑的所有问题）
    - 领域模式（一个对象解决一个特殊问题，有新问题就新增一个对象）
    - 表模式（一个表对应一个内存中的对象，大部分操作都是表操作）

- 服务层
    - 边界，用户层之下
    - 特点    
        - 提供 / 集成一些非领域 / 通用 /  可重用服务（邮件发送，日志）
        - 相对粗粒度
        - 通常以事务形式组织代码

## 数据源架构模式
- 表数据入口
- 行数据入口
    数据库行操作代码，表操作代码直接写入c#
    
- 领域入口
    实现领域模型
    调用表入口或者行入口
    
- 活动记录
    行入口，领域操作方法同时实现在一个类中
    
- 数据库映射器
    动态反射实现数据库操作，内存中实现数据同步操作（如何实现高性能读取，同时响应在并发请求时保证数据正确的 读（没有脏读）写（没有写覆盖）是关键）
    
## 对象-关系行为模式
- 工作单元
    - 维护受业务事务影响的对象列表，而不是在每次修改后立即修改数据库（一个事务完成的过程间）从而提高数据库性能（避免频繁读写）
    工作单元可以直接维护业务的一致性
    
    - 工作单元加载对象，更新对象的三种模式
        - 调用者注册（调用者生成对象，调用者将对象注册到工作单元）
        - 对象注册（调用者生成对象，对象将自己注册到工作单元）
        - 工作单元控制器（调用者调用工作单元，工作单元生成对象，更新后工作单元比对对象和工作单元缓存的内容，确定需要更新的部分）
        
- 标识映射
    - 通过在映射中保存每个已加载的对象，确定对象只加载一次，当要访问对象时，通过映射来查找它们
    - 键选择
        - 数据库表的键
        - 自定义的键
    - 显示的还是通用的
        - findPerson(1)
        - find('person', 1)
    - 数量
        - 一对一（有一个整个会话的标识）
        - 一对多（每个对象有一个标识）
    - 映射放在哪里
        - 进程上下文中

    - 使用时机
        - 标识唯一对象
        - 相等测试

- 延迟加载
    - null
    - 虚代理（在类初始化时加载加载器，调用数据时调用加载器）
    - get / set
    - ghost（通过超类为ghost对象标识了loaded, loading三种状态）
    - 使用时机
        - 有真正的额外调用时去使用（比如真的需要调用两次代码）
        
        
## 关系元数据映射模式
- 元数据映射是什么？
    - 以一种简单的表格形式来定义 数据库中，内存对象的 映射关系，从而实现RUD的相关功能

- 元数据映射的工作流程 / 相关模块
    - 保存元数据 （表，列）
    - 利用元数据构建查询语句的表，列部分
    - 利用元数据将每个字段依次放入内存对象（load, loadFields, setFields）

- 查询对象是什么
    - 一个数据结构，用来构造sql语句某个查询部分(通常是where的部分)  criteria { operator=">", field="lastName", value="fowler"}

- 资源库是什么
    - 资源库封装了保存在数据存储中的对象集以及在这些对象上执行的操作，提供一个更加符合面向对象观点的持久层实现
        